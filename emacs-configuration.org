#+TITLE: Setup Emacs for Java Development
* Introduction
  In this tutorial I will go through setting up emacs for java development. This tutorial will mostly center around setting up packages required to setup Language Server Protocol (LSP) and how to use it for java projects. I will start by setting up emacs and along the way suggest installing packages that will make he life of a java developer much easier. I will use ~use-package~ for package management.
* Setup
  In this setup I will use org-mode configuration file. Emacs init file will call org configuration file. This setup helps us concentrate setting with documentation. First Let's setup how we can call the org configuration file. For this tutorial I assume your emacs initialization file is *init.el* inside ~~/.emacs.d~ folder. Our org-mode configuration file is named *emacs-configuration.org*. 
** Setup init.el
   We will use ~org-babel-load-file~ to load our org-mode configuration file. Before that we will also add some settings as a wrapper which will speed up emacs load time. Add following to your init.el file. Make sure to adjust the path in Windows.
#+begin_example

;; Avoid garbage collection at statup
(setq gc-cons-threshold most-positive-fixnum ; 2^61 bytes
      gc-cons-percentage 0.6)

;; All the settings and package installation is set in configuration.org
(org-babel-load-file "~/.emacs.d/emacs-configuration.org")

(add-hook 'emacs-startup-hook
  (lambda ()
    (setq gc-cons-threshold 16777216 ; 16mb
          gc-cons-percentage 0.1)))
#+end_example
Note that once you start using emacs with this configuration, there may be many autogenerated lines added after above section in your init.el file. You can always ignore or delete those if you want to commit your emacs cofiguration to github or use it in another computer.
** Setup repository in org file
   Here, we will setup package repository. These package repository will help us install various packages including ~use-package~. We will use ~use-package~ to install other packages. Create a file called ~emacs-configuration.org~ inside .emacs.d (or where your init.el is located). You can mix code and normal text in this file. Any time I specify to add code, please include that part of the code inside ~#+BEGIN_SRC emacs-lisp and #+END_SRC block~ E.g.,


Note ~emacs-lisp~ in above block. This tells the code inside ~#+BEGIN_SRC and #+END_SRC~ is emacs-lisp code. Since we asked init.el to load this file, it will execute above block of code. If you start emacs, you will notice a file called ~emacs-configuration.el~ is created, which contains all the lisp blocks included in our ~emacs-configuration.org~ file. You can have as many emacs-lisp SRC block as you need. This kind of setup helps you mix code with powerful org-mode documentation.

Now, go ahead and add following block to your configuration file. From here on, when I mention config or configuration or emacs-configuration.org, it means same file.


 #+BEGIN_SRC emacs-lisp
 (require 'package)

 (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                          ("elpa" . "https://elpa.gnu.org/packages/")
			  ("org" . "https://orgmode.org/elpa/")
 ))


 (package-initialize)

 ; Fetch the list of packages available 
 (unless package-archive-contents (package-refresh-contents))

 ; Install use-package
 (setq package-list '(use-package))
 (dolist (package package-list)
 (unless (package-installed-p package) (package-install package)))

 #+END_SRC

You can add any documentation outside the SRC block. Once you add above code block go ahead and load init.el file. You can load init.el and effectively your configuration using ~M-x load-file~ When load file prompts for the file specify the location of ~init.el~ file. In my example I am loading it from a different directory than my primary emacs setup, that should not confuse you. You will most likely load it from ~/.emacs.d or appropriate Windows directory.

You can either use ~M-x load-file~ command to load init.el or select the section that has lisp code and call ~M-x eval-region~. Both will load the lisp code properly.

** Environment Setup

   In this section, we will setup some global variables and initialize path, so that our emacs recognizes them correctly. Some setup of LSP requires location of java, therefore let's setup that.

*** Emacs Configuration   
    First let us tell this configuration file, where our EMACS configuration is located and what our init file is called. This way we could use a short-cut key (key-binding) to load init.el without having to type ~load-file~ command. Add following code to initialize EMACS_DIR and USER_INIT_FILE variables

Go ahead and evaluate above code. To see if the variables were set properly you can use ~print~ command like below and evaluate the to see the result.
 ~(print EMACS_DIR)~

 In my case it printed ~Desktop/java_emacs/~. This is where my setup is for current tutorial.

    Next we need to setup Java path. By default emacs does not recognize PATH variable especially in some Operating Systems. For consistent experience let us install a package called ~exec-path-from-shell~ and initialize it. Add following code to your configuration file.
 #+begin_src emacs-lisp
 (use-package exec-path-from-shell :ensure t)
 (exec-path-from-shell-initialize)
 #+end_src

** Operating System specific variable setup
    In this section we will refer to 3 files namely windows.el, linux.el and mac.el. We will put any operating system specific settings to appropriate directories. Go ahead and create these files specific to the operating system you use. If you want to use this configuration for multiple operating system you can create one file for each operating system. E.g I mostly use Mac and Linux, therefore I have setup them.

E.g. My linux.el has following code
#+begin_example
(setenv "JAVA_HOME" "/usr/lib/jvm/java-14-openjdk-amd64")
#+end_example

and my mac.el has following code

#+begin_example
(setenv "JAVA_HOME"
        "~/Documents/lib/jdk-11_0_8_10/Contents/Home/")
(setq lsp-java-java-path "~/Documents/lib/jdk-11_0_8_10/Contents/Home/bin/java")
#+end_example

In my Mac I have different versions of java that I use for my primary development vs that I use for LSP with emacs. With above setup, you can use any java version and it does not interfere with your Operating System specific JAVA_HOME variable. Also, if you notice I had to set ~lsp-java-java-path~ in Mac and not in Linux. In Linux I am using same java version for my primary setup and LSP, so I did not have to specifically tell it to use different version. Note, there is no ~BEGIN_SRC and END_SRC~ for code in linux.el and mac.el section. As they are pure lisp files, you don't add these blocks. You just add code to these files.

Next, we need to tell our emacs configuration to load these files. Add following code to your emacs org configuration file.


#+BEGIN_SRC emacs-lisp
 ;; Load platform specific variables using specific files. E.g linux.el. 
 ;; Make necessary changes as needed
 (cond ((eq system-type 'windows-nt) (load (concat EMACS_DIR "windows")))
 ((eq system-type 'gnu/linux) (load (concat EMACS_DIR "linux")))
 ((eq system-type 'darwin) (load (concat EMACS_DIR "mac")))
 (t (load-library "default")))
 #+END_SRC
This will load mac.el, linux.el or windows.el depending upon your operating system.

* Basic bells and whistles settings
  In this section, we will setup some basic emacs configuration that will enhance our experience. Let's setup them one by one. I will list out comment for each part. Copy the code in the next code block.

** Basic setup
#+BEGIN_SRC emacs-lisp
;; Disable annoying ring-bell when backspace key is pressed in certain situations
(setq ring-bell-function 'ignore)

;; Disable scrollbar and toolbar
(scroll-bar-mode -1)
(tool-bar-mode -1)

;; Set language environment to UTF-8
(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8)

;; Longer whitespace, otherwise syntax highlighting is limited to default column
(setq whitespace-line-column 1000) 

;; Enable soft-wrap
(global-visual-line-mode 1)

;; Maintain a list of recent files opened
(recentf-mode 1)            
(setq recentf-max-saved-items 50)

;; Move all the backup files to specific cache directory
;; This way you won't have annoying temporary files starting with ~(tilde) in each directory
;; Following setting will move temporary files to specific folders inside cache directory in EMACS_DIR

(setq user-cache-directory (concat EMACS_DIR "cache"))
(setq backup-directory-alist `(("." . ,(expand-file-name "backups" user-cache-directory)))
      url-history-file (expand-file-name "url/history" user-cache-directory)
      auto-save-list-file-prefix (expand-file-name "auto-save-list/.saves-" user-cache-directory)
      projectile-known-projects-file (expand-file-name "projectile-bookmarks.eld" user-cache-directory))

;; Org-mode issue with src block not expanding
;; This is a fix for bug in org-mode where <s TAB does not expand SRC block
(when (version<= "9.2" (org-version))
(require 'org-tempo))

;; Coding specific setting

;; Automatically add ending brackets and braces
(electric-pair-mode 1)

;; Make sure tab-width is 4 and not 8
(setq-default tab-width 4)

;; Highlight matching brackets and braces
(show-paren-mode 1) 
#+END_SRC

* Looks (Optional)
If you are fine with how emacs looks then this section is optional for you. You can go ahead and jump to next part. Here we will try to setup theme and font.

Note: Use this document instead of other for rest of the part.
** Theme
   I tend to like doom-themes. Below we will install doom theme. In addition, I will also install another package called heaven-and-hell. This allows us to toggle between two themes using a shortcut key. I will assign "<f6>" key to toggling the theme and "C-c <f6>" to set to default theme. Load following code into your emacs configuration.

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
:ensure t 
:init 
(load-theme 'doom-palenight t))

(use-package heaven-and-hell
  :ensure t
  :init
  (setq heaven-and-hell-theme-type 'dark)
  (setq heaven-and-hell-themes
        '((light . doom-acario-light)
          (dark . doom-palenight)))
  :hook (after-init . heaven-and-hell-init-hook)
  :bind (("C-c <f6>" . heaven-and-hell-load-default-theme)
         ("<f6>" . heaven-and-hell-toggle-theme)))

#+END_SRC

If you press F6 key in your keyboard, it should switch between doom-palenight and doom-acario-light themes. If you want to go back to the default theme press "Ctrl + C F6". See above how the function and Ctrl keys are written in emacs.

** Font
Fonts are integral part of a text editor / IDE. I tend to like "DejaVu Sans Mono" fonts. If you have not setup this "DejaVu Sans Mono" in your Operating System, it is time to do so now. Go ahead and install it [[https://dejavu-fonts.github.io/Download.html][from this link]]. After that add following configuration.

#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(font . "DejaVu Sans Mono-16"))
#+END_SRC

** Disable ansi color in compilaiton mode
   This will help eliminate weird escape sequences during compilation of projects.
   #+begin_src emacs-lisp

   (defun my/ansi-colorize-buffer ()
   (let ((buffer-read-only nil))
   (ansi-color-apply-on-region (point-min) (point-max))))
   
   (use-package ansi-color
   :ensure t
   :config
   (add-hook 'compilation-filter-hook 'my/ansi-colorize-buffer)
   )
   #+end_src
* Required Custom Packages
  In this section we will install some of the required packages which we will use throught the rest of the configuration. 

** Key-Chord
   Key-Chord allows us to bind regular keyboard keys for various commands without having to use prefix keys such as Ctrl, Alt, Super etc. We will use key-chord for various useful commands that we want to use quite often.

#+begin_src emacs-lisp
(use-package use-package-chords
:ensure t
:init 
:config (key-chord-mode 1)
(setq key-chord-two-keys-delay 0.4)
(setq key-chord-one-key-delay 0.5) ; default 0.2
)
#+end_src
Here, we changed the delay for the consecutive key to be little higher than default. Adjust this to what you feel comfortable.

* Java Setup
  In this section we will install several packages that helps to setup java development.

** Projectile
   Projectile helps us with easy navigation within a project. Projectile recognizes several source control managed folders e.g git, mercurial, maven, sbt, and a folder with empty .projectile file. It helps to jump to a file, file at point, directory, test, multi-occur, replace, run make etc. We will later install helm to use with projectile. Add following code to enable projectile first.

#+begin_src emacs-lisp
(use-package projectile 
:ensure t
:init (projectile-mode +1)
:config 
(define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
)   
#+end_src

Go ahead and evaluate above code. You should now be able to type ~M-x projectile-~. If you press TAB after you type "projectile" in command bar, you should start seeing the projectile functions.
[Figure 2, Projectile]

If you notice above we have assigned "Ctrl + C p" keyboard shortcut to projectile. If you type "Ctrl + C p", you see nothing happens. To learn what options you have available, you could type "Ctrl + h b" and search for projectile, using "Ctrl + s" and typing "projectile". You should be able to see all the key bindings associated with "Ctrl + c" prefix. However, searching this  way is a little bit tedious. 

** Helm
We are lacking couple of necessary functionalities. When I type M-x (Alt-x), I want emacs to help me complete the command. I want similar functionalities when finding (open) files, list recent files and so on. Let's install helm and enable add/override couple of keys to use helm replacements.

#+BEGIN_SRC emacs-lisp
(use-package helm
:ensure t
:init 
(helm-mode 1)
(progn (setq helm-buffers-fuzzy-matching t))
:bind
(("C-c h" . helm-command-prefix))
(("M-x" . helm-M-x))
(("C-x C-f" . helm-find-files))
(("C-x b" . helm-buffers-list))
(("C-c b" . helm-bookmarks))
(("C-c f" . helm-recentf))   ;; Add new key to recentf
(("C-c g" . helm-grep-do-git-grep)))  ;; Search using grep in a git project
#+END_SRC

Go ahead and evaluate above code. Let me go through what each options do.
+ We enabled fuzzy matching with helm, so in each helm search buffer you can type text fuzzily. E.g If you want to match "This is a text", you could type "T s t"
+ Just like we added "C-c p" as a prefix for projectile, we added "C-c h" as a prefix to helm. Any helm command we don't rebind to something else will have a prefix of "C-c h"
+ We also changed "M-x" to use helm-M-x. If you now type M-x it uses a more convenient way to type commands.
+ Next we rebind "C-x C-f" to helm-find-files. This is much better than default find-files.
+ We changed "C-x b" to helm-buffers-list. Helm-buffers-list is a convenient way manage buffers. E.g. You can select multiple buffers with space key, and use "C-c d" to delete the selected buffers. At the bottom, you also get suggestions for using other options.
+ We also added a new command "C-c b" to helm-bookmarks. You can still access and manage bookmarks using "C-x rl", but helm-bookmarks is an easier way to manage bookmarks. If you want to rename bookmarks, there is helm-bookmark-rename, or you could use the bookmark-bmenu-list with "C-x rl" to manage bookmarks.
+ If you remember, in the "Bells and whistles" section we enabled recentf and told it to maintain a list of 50 recent files. If you type "C-c f", you can easily access your recent files. This should be one of the most used commands other than "C-x C-f" and "M-x"
+ Finally we add "C-c g" to helm-grep-do-git-grep. If you issue "C-c g" and start typing text nothing should happen, unless you are searching tracked files in a git project. Let's create a simple git maintained java folder so that we can experiment with above command. Create a folder called "simple_java_project" and add a file called HelloWorld.java with following text.
#+begin_src java
import java.util.*;

public class HelloWorld
{
    public static void main(String[] args)
    {
	System.out.println("Hello, World");
	System.out.println("This is a text");
    }
}
#+end_src

Let's initialize git and commit above file. For that open up a terminal and go to above folder and run following commands (without the prompt part)
#+begin_src sh
$ git init .
$ git add HelloWorld.java
$ git commit -m "Add Hello World"
#+end_src
TODO: [Picture 3 Java File]

You can now browse to the file/folder from emacs using "C-x C-f" and use "C-c g" to search text in any file of the project.

TODO: [Picture 4 Helm git]

You can be anywhere in the project, e.g., working on a file or browsing some directory, if you use "C-c g" you can search for any file that has some text you know its there. If you notice in the screenshot, I used vim and created the file externally using terminal emulator. You could do all of these activities using emacs as well. There is a shell mode in emacs call eshell. You can type your git commands in the terminal. To create above file and associated folder you can use "C-x C-f" and type the desired directory and file name e.g ~/Desktop/simple_java_project/HelloWorld.java, type above code and save it with "C-x C-s". Go ahead and experiment with above commands before moving forward.

*** Helm Descbinds
While we are at the topic of helm, let's install couple of other packages as well. I mentioned above that you can use "Ctrl + h b" to call (describe-bindings). It shows commands bound to various emacs commands. I want to replace that with much better interface. Go ahead and install helm-descbinds and assign it to "Ctrl + h b" as described below.
#+begin_src emacs-lisp
(use-package helm-descbinds
:ensure t
:bind ("C-h b" . helm-descbinds))
#+end_src

Once you evaluate above code and type "C-h b" you should have a much better interface where you can search for commands that have a keyboard binding. If you type "helm" or "projectile" you can see all the keys that have "C-c h" and "C-c p" prefixes along with the keys we have overwridden with other keys. This interface should be one of the ways for you to learn and memorize shortcuts for your favorite commands.

*** Helm swoop
We have installed packages to manage and search within a project, but how about searching and working within the current file that we are working on. Helm swoop is one of the packages that helps to quickly jump at various texts within same file. If you have gone through emacs tutorial you should already know form "Searching" section that you can use "C-s" and "C-r" multiple times to search forward and backward within a file. Helm-swoop will be a complement already powerful emacs search. Install helm-swoop.
#+begin_src emacs-lisp
(use-package helm-swoop 
:ensure t
:chords
("js" . helm-swoop)
("jp" . helm-swoop-back-to-last-point)
:init
(bind-key "M-m" 'helm-swoop-from-isearch isearch-mode-map)

;; If you prefer fuzzy matching
(setq helm-swoop-use-fuzzy-match t)

;; Save buffer when helm-multi-swoop-edit complete
(setq helm-multi-swoop-edit-save t)

;; If this value is t, split window inside the current window
(setq helm-swoop-split-with-multiple-windows nil)

;; Split direcion. 'split-window-vertically or 'split-window-horizontally
(setq helm-swoop-split-direction 'split-window-vertically)

;; If nil, you can slightly boost invoke speed in exchange for text color
(setq helm-swoop-speed-or-color nil)

;; ;; Go to the opposite side of line from the end or beginning of line
(setq helm-swoop-move-to-line-cycle t)

)
#+end_src

You should now be able to search visually within current buffer with "js" key. To go back to where you started searching press "jp". If you are within "C-s" or "C-r" window you can type "M-m" (Alt + m) to start searching with helm-swoop. You can press "C-n", "C-p" to go through different lines matched by helm-swoop. For other options type "swoop" in M-x window and go through various commands. You can also also go through options shown in helm-swoop [[https://github.com/emacsorphanage/helm-swoop][github page]]. E.g. When you are searching in a buffer, you can use "M-i" to apply it to multipe open buffers and if you want to change some text to something else, you can type "C-c C-e" to open up edit window. Edit the buffers and when you save it, the changes will apply to all opened buffers. You can use replace-regex to select and replace multiple text in a file.

TODO: [Image 6]
** More ways to navigate a buffer (Optional)
   Above we used helm-swoop to jump around quickly in a buffer or other open buffers. In this section we will add one more program that helps to jump within current file even more easily. We will use avy package. Avy allows to jump to particular character, word or line within a file using two keys. I am using "jc", "jw" and "jl" to jump to character, word and line respectively. If you feel these sequences of characters are used for other purpose, you can change them to something else. Since I have found I don't use "jc", "jw" or "jl" most frequently, I have used these sequence here. If you need to use "jc", "jw" or "jl" literally as text, then all you have to do is type them slow then when you want to execute these keys. Adjust the key-chord delay values in use-package-chords (above) to a comfortable delay to adjust what is comfortable time between when you want to type these characters literally in a text vs when you want to use them as keys. If it is confusing, you can change them with some key modifiers like "ctrl", "alt" or "super" keys. You can use :bind instead of :chords.

#+begin_src emacs-lisp
(use-package avy 
:ensure t
:chords
("jc" . avy-goto-char)
("jw" . avy-goto-word-1)
("jl" . avy-goto-line))
#+end_src
TODO: [Image 09 - Avy Jump]
E.g If you want to jump to a character you see in scren press "jc". Type the character of the place where you want to jump. If there are more than 1 such characters, emacs will provide more keys you can type to jump to any one of them. Same technique works for jumping to a line or word.
** Guide Me
   As we saw above helm and projectile is nice and all, but I don't think anyone has enough time or patience to hunt through all the options it provides. It is not a wise design to demand users to remember all the various key bindings. Wouldn't it be nice, if emacs guides us through various options. Next, we will install a package called which-key. Which key shows various options available for a parent command. E.g If you just remember "C-c h" is associated with helm commands and "C-c p" is associated with projectile commands, rest is easy peasy. Let us first install which-key package and we will see how it works.

#+begin_src emacs-lisp
(use-package which-key 
:ensure t 
:init
(which-key-mode)
)
#+end_src

Once you evaluate above code and type "C-c p" or "C-c h" you should see a menu at the bottom that shows what you can type next to browse rest of the options. For some keys there will be more options available, that starts with the +prefix. If you type the associated key, you will be able browse more options. Some times all the options don't fit in a single page. To browse other pages, first you have to type "C-h" and then you will be able to type "n" or "p" to jump between next or previous command pages.

TODO: [Image 07 - Helm WHich Key]
** Run Code
We can use quickrun package. This package runs various source files. E.g. If you have a java file with main method, it will run with the associated shortcut key (C-c r) or quickrun command. Quickrun has support for several languages.
#+begin_src emacs-lisp
(use-package quickrun 
:ensure t
:bind ("C-c r" . quickrun))
#+end_src

You can quickly jump to the section where the error is seen from *quickrun* message buffer. This is helpful to run small java programs. For large projects you should use maven or gradle.

TODO: [08-quickrun]
** Language Server Protocol (LSP)
  With above setup, now we are ready to install and use LSP. Here I will start the most basic setup of LSP. We will add more features and more packages to support various other options. Following setup is language agnostic. For java it will use Eclipse jdtls server by default. For what server is installed for other languages, see this [[https://langserver.org/][Language Server]] page.
#+begin_example
(use-package lsp-mode
:ensure t
:init (setq 
    lsp-keymap-prefix "C-c l"
    lsp-enable-file-watchers nil
))
#+end_example

After installation, all you have to do is open a java file and enable lsp (C-c l s s). LSP might ask for the root directory for the first time, specify the folder where you have your project. Depending upon the server environment, it might indiciate what is missing to setup the server. E.g If you had setup java environment correctly, it should download the jdtls server.

Let's say you want to enable language server for c++, open a c++ file and enable lsp, if you did not have clangd installed, you should see following error.

#+begin_example
LSP :: The following servers support current file but do not have automatic installation configuration: clangd
You may find the installation instructions at https://emacs-lsp.github.io/lsp-mode/page/languages.
(If you have already installed the server check *lsp-log*).
user-error: Minibuffer window is not active
#+end_example

In debian like linux distribution you can search for latest version of clangd using "apt search" and install accordingly.
#+begin_src sh
$ apt search clangd
$ sudo apt install clangd
#+end_src

After installing clangd go ahead and open open the c++ file again and enable lsp. It should now prompt for the root folder. It should show that LSP is started. 
Let's say your c++ file looks like following code

#+begin_src cpp
#include <iostream>

using namespace std;

int main()
{
  int a = 2;
  cout << "Hello World\n";
  cout << "Value of a is " << a;
  return 0;
}
#+end_src

If you cursor is at variable a in second cout, you could execute ~lsp-ui-peek-find-definition~ to jump to the place where a is initially defined ~int a = 2~. Same behavior happens for a java project.


For a java file, once you start typing ~System.out~ it should list out available methods for autocomplete. If you hover over a keyword it should print available javadoc documentation if available.

TODO: [Figure 10-lsp-autocomplete]
TODO: [Figure 10-lsp-documentation.png]

At this point, you should get an idea of what LSP is and what it is not. It provides help for writing code, but not for debugging and running the project.

** Enhance UI with which key integration 
One thing you might have noticed with LSP options is, it shows the prefix keys, but options like G, T, a, g, h are not very intutive to see what type of functions are grouped under that prefix. Let's improve that. Let's add a hook section in above lsp-mode use-package block to enable which-key-integration

#+begin_src emacs-lisp
(use-package lsp-mode
:ensure t
:hook (
   (lsp-mode . lsp-enable-which-key-integration)
   (java-mode . #'lsp-deferred)
)
:init (setq 
    lsp-keymap-prefix "C-c l"
    lsp-enable-file-watchers nil
    read-process-output-max (* 1024 1024)  ; 1 mb
    lsp-completion-provider :capf
    lsp-idle-delay 0.500
)
:config 
    (setq lsp-intelephense-multi-root nil) ; don't scan unnecessary projects
    (with-eval-after-load 'lsp-intelephense
    (setf (lsp--client-multi-root (gethash 'iph lsp-clients)) nil))
)
#+end_src

Once you evaluate above code, you can use "C-c l s r"  to restart the server again. After restarting if you use "C-c l" which-key (menu options) should show proper headings like in the figure below. Also, I have added some memory management settings as suggested in [[https://emacs-lsp.github.io/lsp-mode/page/performance/][this guide]]. Change them to higher numbers, if you find lsp-mode sluggish over time.


TODO: [LSP which key]

 See more here in [[https://github.com/emacs-lsp/lsp-java][lsp-java git page]]. 

TODO: FIXME
*LSP-Mode package installs couple of other packages like company, yasnippet, dap-mode, treemacs, lsp-ui, lsp-java, helm-lsp etc. If you want to configure behavior of individual packages you can configure them using use-package, just like you installed them. Let's go through couple of them and see what they bring to the table.*

*** Company
Complete anything aka Company provides provides text autocompletion. Install company package using following command.
#+begin_src emacs-lisp
(use-package company :ensure t)
#+end_src

You can toggle autocomplete by enabling and disabling company-mode in your current buffer. As you type your text, it should provide any autocomplete, if it is available. Company-capf is enabled by default when you start lsp server on a project. You can also invoke ~M-x company-capf~ to enable capf (completion at point function), as some snippets might not expand properly without calling ~M-x company-capf~.

TODO: [LSP company capf]

*** Yasnippet
Yasnippet is a template system for emacs. It allows you to type abbreviation and complete that to associated text. In addition to ~company-capf~, you can also invoke ~M-x company-yasnippet~ command for completion.

TODO: [LSP company yasnippet]. 

If you like one of these functionalities, you can also add a keyboard-binding to invoke one of the above commands. I would like to add yas-global-minor mode as an option. Go ahead and add following code to enable that.
#+begin_src emacs-lisp
(use-package yasnippet :config (yas-global-mode))
(use-package yasnippet-snippets :ensure t)
#+end_src

With this you can see magic happen. If you have gone through various options of ~company-yasnippet~ you can see the abbreviations associated with your favorite functions. E.g In java ~pr~ is associated with ~System.out.println~. With above code all you have to do is type the keyword and press ~TAB~. E.g ~pr <TAB>~ extands to ~System.out.println("text"). The cursor moves to "text" part, where you can type the text you need. If you don't want to type literal text, just press backspace couple of times, and it should let you use invoke methods from your object.


This is sweet and all to use existing functionalities of YaSnippet, but what if I want to add my own set of keyword and associate code to it. Does YaSnippet allows us to add new custom snippets?
And the answer is yes. To create a new snippet you can invoke ~M-x yas-new-snippet~ command. Give a name to it, and for the key section add the key that you will type before hitting TAB. And insert any text that key should expand after next line of double dash line (--). 

For example, I usually like to create a barebone Solution class with java.util package initialized and my class defined. Here is what it would look like.

TODO: [yas-new-snippet]

It asked me to save the snippet to my emacs directory/snippets/java-mode directory. Now, whenever I want to create above code in java-mode, I type "sol" and press <TAB>. If you noticed, there is a $0 after the first block of code in Solution class. This is where my cursor will stop after I expand the text. For what options are available while writting new snippet, check this [[https://joaotavora.github.io/yasnippet/snippet-development.html][web page]]. If anytime you need to modify your existing snippet use ~yas-visit-snippet-file~. E.g If I want to change the key word used for expansion or change the replaced text, I use above command, search for the snippet, I want to change and save it after modification.



*** Dap Mode
Emacs Debug Adapter Protocol aka DAP Mode allows means to debug your program, just like LSP. You can add break points, run and debug your program. See available options and commands [[https://emacs-lsp.github.io/dap-mode/page/features/][here]]. If you start ~dap-debug~ without adding a break point, it will run your code. To add a breakpoint use ~dap-breakpoin-add~ command, or press on the left side of your java code to enable the breakpoint circle.

TODO: [13. DAP debug add break point]

Once you start ~dap-debug~ you may see screen as below. Select "Java Attach" or "Java Run Configuration (compile/attach)" from the menu.

TODO: [13. Dap debug]

Once you start dap-debug you should see a screen just like this.

You can use the buttons at the top to step-in, step-out, step-over your code or disconnect the session. Let's add some keyboard shortcut and integrate it with a package called dap-hydra, so that we can use use simple keys like n, p etc.

#+begin_src emacs-lisp
(use-package dap-mode
  :ensure t
  :after (lsp-mode)
  :functions dap-hydra/nil
  :config
  (require 'dap-java)
  :bind (:map lsp-mode-map
         ("<f5>" . dap-debug)
         ("M-<f5>" . dap-hydra))
  :hook ((dap-mode . dap-ui-mode)
    (dap-session-created . (lambda (&_rest) (dap-hydra)))
    (dap-terminated . (lambda (&_rest) (dap-hydra/nil)))))
#+end_src

TODO: [13. Dap hydra]

Hydra package as a standalone package is a superb emacs package. You can use it to add keys to customize so many options. E.g. I use it to control EMMS (Music), manage multiple windows, jump to my favorite websites with shortcut keys and when I am lazy, use vim like keys to navigate around in emacs. You can check [[https://github.com/neppramod/emacs-configuration/blob/master/configuration.org#hydra-1][Hydra section]] in my emacs configuration.

*** Dap Java
#+begin_src emacs-lisp
(use-package dap-java :ensure nil)	
#+end_src

*** Helm LSP
Helm-lsp package is part of lsp-mode installation. It provides various useful functions for coding. One such function is ~helm-lsp-code-actions~ ~C-c l a a~. It provides various helper functions like organizing imports, generating getters, setters, constructor, toString etc. You can use ~helm-lsp-workspace-symbol~ to find various symbols (classes) within your workspace. Since lsp has downloaded source code for java into its workspace, you will not only be able to see your own classes in the workspace but search various standard java classes with this and quickly jump to it. You can also use ~helm-lsp-global-workspace-symbol~. 

TODO: [14, Lsp Symbol]

LSP's built in symbol explorer uses ~xref-find-apropos~, which provides basic symbol navigation. You can see it using ~C-c l g a~ and type the text of the symbol. E.g. "System". Let's replace that with helm-lsp. We can execute following command to give power to our ~C-c l g a~.

#+begin_example 
(define-key lsp-mode-map [remap xref-find-apropos] #'helm-lsp-workspace-symbol)
#+end_example

However, since we want to make sure helm-lsp starts after lsp-mode, execute following code instead.

#+begin_src emacs-lisp
(use-package helm-lsp
:ensure t
:after (lsp-mode)
:commands (helm-lsp-workspace-symbol)
:init (define-key lsp-mode-map [remap xref-find-apropos] #'helm-lsp-workspace-symbol))
#+end_src

Now when you type ~C-c l g a~ it should invoke ~helm-lsp-workspace-symbol~ function instead.

*** FlyCheck
FlyCheck checks for errors in code at runtime.
#+begin_src emacs-lisp
(use-package flycheck :ensure t :init (global-flycheck-mode))
#+end_src

*** Treemacs
Treemacs provides UI elements used for LSP UI. Let's install lsp-treemacs and its dependency treemacs. We will also Assign "M-9" to show error list
#+begin_src emacs-lisp
(use-package lsp-treemacs
  :after (lsp-mode treemacs)
  :ensure t
  :commands lsp-treemacs-errors-list
  :bind (:map lsp-mode-map
         ("M-9" . lsp-treemacs-errors-list)))

(use-package treemacs
  :ensure t
  :commands (treemacs)
  :after (lsp-mode))
#+end_src

*** LSP UI
Other dependent package of lsp-mode are ui packages. We already saw several UI elements e.g. in dap-mode which is provided by these packages. If you want to see code navigation and symbol in a ui, you can enable these methods. E.g ~lsp-ui-imenu~ shows a simple ui listing methods and variables in a side bar, you an quickly jump to various sections in the editor ui using the ui menu.

TODO: [15. LSP-UI]

If you want to see flycheck erros you can invoke ~lsp-ui-flycheck-list~. It will open a window, where you can see various coding errors while you type. LSP highlights various UI suggestions for errors and issues, but this might be more convenient. 

Note: If you find some of the UI options distracting, you can toggle them using ~C-c l T~ and using various options provided in the menu.

One neat feature that is built-in in emacs to jump around between class definition and its implementation is using "M-." key. You can browse back to previous point using "M-," key. "M-." is assiged to ~xref-find-definitions~ function and " M-," is assigned to ~ref-pop-marker-stack~ unction. In addition there is "M-?" to quickly find references in the project. You should use these commands for fast navigation.

Let's improve these by remapping xref-find-definitions and xref-find-references to lsp-ui functions.
#+begin_src emacs-lisp
(use-package lsp-ui
:ensure t
:after (lsp-mode)
:bind (:map lsp-ui-mode-map
         ([remap xref-find-definitions] . lsp-ui-peek-find-definitions)
         ([remap xref-find-references] . lsp-ui-peek-find-references))
:init (setq lsp-ui-doc-delay 1.5
      lsp-ui-doc-position 'bottom
	  lsp-ui-doc-max-width 100
))
#+end_src

Go throught this: https://github.com/emacs-lsp/lsp-ui/blob/master/lsp-ui-doc.el and see what other parameters you like.

*** LSP-Java
This package is the one that deals with the server installation and so on.
#+begin_src  emacs-lisp
(use-package lsp-java 
:ensure t
:config (add-hook 'java-mode-hook 'lsp))
#+end_src

*** Other LSP Commands.
Go through [[https://github.com/emacs-lsp/lsp-java#supported-commands][Supported commands]] section of lsp-java github page to see commands provided in lsp-mode. Most of these commands are catagories under lsp's ~C-c l~ option. Some of the most useful functionalities are under refactoring, testing and dependency viewer and the one we described above ~lsp-symbol-navigation~

*** Spring Support
LSP comes with ~lsp-java-spring-initializer~ an emacs interface for [[https://start.spring.io/][start.spring.io]] (spring initializer). You can create spring project using this interface. 

* Coding
** Create project
   Use the ~lsp-java-spring-initializer~ to create a project. For this example, I will use the default option to create the project.

** Create a class
   Create a java class in com.example.demo package called Person.java with following code
#+begin_src java
package com.example.demo;

public class Person {
    private String name;
    private String title;

    public String getTitle() {
	return title;
    }
    public void setTitle(String title) {
	this.title = title;
    }
    
    public String getName() {
	return name;
    }
    public void setName(String name) {
	this.name = name;
    }    
}   
#+end_src

** Unit Test
Also create a unit test class called PersonTest.java inside demo/src/test/java/com/example/demo/PersonTest.java with following code
#+begin_src java
package com.example.demo;

import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

public class PersonTest
{
    @Test
    public void testMethods() {
	Person p = new Person();
	p.setName("Monkey D. Luffy");
	p.setTitle("Pirate King");

	assertEquals(p.getName(), "Monkey D. Luffy");
	assertEquals(p.getTitle(), "Pirate King");
    }
}
#+end_src

You can use various functions of lsp to autocomplete, organize imports and so on to complete above code. After finishing coding, execute ~dap-java-run-test-class~ to run PersonTest unit test. If you see below image you can see it ran one test with success. 

TODO
[17 spring unit est]

Note: You may see weird symbols for graphical element just like in above image. I have not been able to identify what enables those symbols. Let me know if you find out.


An alternative way of coding is using Test Driven Development. You could infact start from unit tests and create necessary classes and methods along the way to complete those tests. LSP's action command (C-c l a a) helps with pretty much implementing any sort of use case.

E.g Let me add a new unit test method that calls for non-existent method in Person class. We will see how we can implement them with TDD approach. Add following test method.

#+begin_src java
 @Test
public void testRole() {
   Person p = new Person();
   p.setRole("Captain");
   assertEquals(p.getRole(), "Captain");
}
#+end_src

You can see LSP-UI suggest us to create method 'setRole(String)' in type 'Person'. You could do samething by using ~C-c l a a~ Once you execute methods for both set and get, you should see something like this.
#+begin_src java
 public void setRole(String string) {
 }

 public Object getRole() {
   return null;
 }    
#+end_src

Go ahead and fix the methods with proper return type and creating a local variable in Person class. In the setRole, if you type ~this.role = role~, the action menu should should suggest you to create a local member variable role. Once the method is completed, you can go back to testRole() method in PersonTest and use ~dap-java-run-test-method~ and run the unit test.

To quickly toggle between unit test class and implementation class you can use ~projectile-toggle-between-implementation-and-test~ assigned to ~C-c p t~

** Maven
   Since this is a maven project lsp provide integration with maven as well. Let's go ahead and compile the project and run the unit tests using maven. Go ahead and execute ~projectile-test-project~ assigned to ~C-c p P~. In the prompt type "mvn test". To run the project you can use ~projectile-run-project~ assigned to ~C-c p u~. Here you can type any maven run command for you project. Go ahead and execute "mvn spring-boot:run". Once it finishes it should show sucess, but there does not seem to be an application running. Let's go ahead and create a simple controller class that returns a greeting message. Go ahead and create following code in example/demo directory. For more reference to this project go through the [[https://spring.io/guides/gs/spring-boot/][spring boot tutorial]].
#+begin_src java
package com.example.demo;

import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.bind.annotation.RequestMapping;

@RestController
public class PersonController {

	@RequestMapping("/")
	public String index() {
		return "Greetings from Spring Boot!";
	}

}
#+end_src

Go to your pom.xml file and make sure you have spring-boot-starter-web added to the dependency section, if not add following code. You can go open any file in your project by using ~C-c p f~. Here you will type pom.xml to find it.

#+begin_src xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
</dependency>
#+end_src

Once you save above code, run the project again. This time you should be able to browse to http://localhost:8080. If you get an error, make sure to add following to your pom.xml. To stop running the program use ~C-c C-k~

TODO: [20-spring-boot-run]

* Conclusion
After going through above tutorial, I am sure you should now be able to work through a java project using LSP in emacs. In many setup, people add hook to java-mode to start LSP right away. In this tutorial, I did not do that. Everytime you start a java project you have to start lsp yourself. When you go back to your java project it is a good idea to restart the lsp server. Use the "C-c l s" menu to handle the server sessions.  If you want to start lsp with each java project without having you go through above step, you can add a java-mode-hook. You can put it in config section of use-package for lsp-mode or lsp-java. It might start lsp mode, but you may have to start the server.

#+begin_example
(add-hook 'java-mode-hook 'lsp)
#+end_example>

Also, please note the memory settings added to lsp-mode. Increase or decrease the value according to your experience.

* References
1. [https://github.com/emacs-lsp/lsp-java][LSP Java]
2. [https://github.com/emacs-lsp/lsp-ui][LSP UI]
3. [https://emacs-lsp.github.io/lsp-mode/page/performance/][LSP Mode Performance] and other pages in this site.
4. [https://spring.io/guides/gs/spring-boot/][Building an Application with Spring Boot]
5. [https://github.com/neppramod/emacs-configuration][My Emacs Configuration Page]. Has some unused settings.
